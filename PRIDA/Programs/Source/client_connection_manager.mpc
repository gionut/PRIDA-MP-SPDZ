####### Adapted from MP-SPDZ/Programs/Source/bankers_bonus.mpc
from Compiler.types import sint, regint, Array, MemValue
from Compiler.library import print_ln, do_while, for_range
from Compiler.util import if_else

class ClientConnectionManager:
    def client_input(self, t, size, client_socket_id):
        """
        Send share of size random values, receive input and deduce shares.
        """
        
        return t.receive_from_client(size, client_socket_id)


    def send_to_client(self, sockets, client_id, value):
        """Send value to client"""

        # Setup authenticate result using share of random.
        # client can validate ∑ value * ∑ rnd_from_triple = ∑ auth_result
        sint.reveal_to_client(sockets.get(client_id), [value])

    def __init__(self, PORTNUM, DO_NUMBER, n_threads):
        self.PORTNUM = PORTNUM
        self.DO_NUMBER = DO_NUMBER
        self.n_threads = n_threads

        # Start listening for client socket connections
        listen_for_clients(self.PORTNUM)
        print_ln('Listening for client connections on base port %s', PORTNUM)

        # Clients socket id (integer).
        self.client_sockets = Array(self.DO_NUMBER, regint)
        # Number of clients
        self.number_clients = MemValue(regint(0))
        # Client ids to identity client
        self.client_ids = Array(self.DO_NUMBER, sint)
        # Keep track of received inputs
        self.seen = Array(self.DO_NUMBER, regint)
        self.seen.assign_all(0)

        # Loop round waiting for each client to connect
        @do_while
        def client_connections():
            client_id = self._accept_client()
            @if_(client_id >= self.DO_NUMBER)
            def _():
                print_ln('client id too high')
                crash()
            self.client_sockets[client_id] = client_id
            self.client_ids[client_id] = client_id
            self.seen[client_id] = 1
            
            return (sum(self.seen) < self.DO_NUMBER)
        
        self.number_clients.write(self.DO_NUMBER)

    def _accept_client(self):
        client_socket_id = accept_client_connection(self.PORTNUM)
        return client_socket_id
    
    def close_connections(self):
        self._close_connections(self.number_clients)

    def _close_connections(self, number_clients):
        @for_range(number_clients)
        def _(i):
            closeclientconnection(i)

    def receive_from_clients(self, t, size):
        # Clients secret input.
        self.client_values = t.Matrix(self.DO_NUMBER, size)

        @for_range_multithread(self.n_threads, 1, self.number_clients)
        def _(client_id):
            self.client_values[client_id] = self.client_input(t, size, client_id)
        
        return self.client_values

# Receive from Data Owners authenticated shares of their choices for Data Customer j 
# if cv[i][j] = 1, then Data Owner i agrees to share data with Data Customer j
# if cv[i][j] = 0, then Data Owner i does not want his data to be shared with Data Customer j
# N - number of Data Owners
# M - number of Data Customers
def receive_data(N, M):
    ccm = ClientConnectionManager(14000, 3, 2)
    shares = ccm.receive_from_clients(sint, 2*M)
    cv = sint.Matrix(N, M)
    d = sint.Matrix(N, M)
    for id in range(N):
        cv[id] = shares[id][:M]
        d[id] = shares[id][M:]
        print_ln(f"cv for data owner {id} is '%s'", cv[id].reveal())
        print_ln(f"cv for data owner {id} is '%s'", d[id].reveal())
    
    ccm.close_connections()

    return (cv, d)

receive_data(3, 3)