####### Adapted from MP-SPDZ/Programs/Source/bankers_bonus.mpc
from Compiler.types import sint, regint, Array, MemValue
from Compiler.library import print_ln, do_while, for_range
from Compiler.util import if_else

class ClientConnectionManager:
    def client_input(self, t, client_socket_id):
        """
        Send share of random value, receive input and deduce share.
        """
        
        return t.receive_from_client(1, client_socket_id)[0]


    def send_to_client(self, sockets, client_id, value):
        """Send value to client"""

        # Setup authenticate result using share of random.
        # client can validate ∑ value * ∑ rnd_from_triple = ∑ auth_result
        sint.reveal_to_client(sockets.get(client_id), [value])

    def __init__(self, PORTNUM, MAX_NUM_CLIENTS, n_threads):
        self.PORTNUM = PORTNUM
        self.MAX_NUM_CLIENTS = MAX_NUM_CLIENTS
        self.n_threads = n_threads

        # Start listening for client socket connections
        listen_for_clients(self.PORTNUM)
        print_ln('Listening for client connections on base port %s', PORTNUM)

        # Clients socket id (integer).
        self.client_sockets = Array(self.MAX_NUM_CLIENTS, regint)
        # Number of clients
        self.number_clients = MemValue(regint(0))
        # Client ids to identity client
        self.client_ids = Array(self.MAX_NUM_CLIENTS, sint)
        # Keep track of received inputs
        self.seen = Array(self.MAX_NUM_CLIENTS, regint)
        self.seen.assign_all(0)

        # Loop round waiting for each client to connect
        @do_while
        def client_connections():
            client_id, last = self._accept_client()
            @if_(client_id >= self.MAX_NUM_CLIENTS)
            def _():
                print_ln('client id too high')
                crash()
            self.client_sockets[client_id] = client_id
            self.client_ids[client_id] = client_id
            self.seen[client_id] = 1
            @if_(last == 1)
            def _():
                self.number_clients.write(client_id + 1)

            return (sum(self.seen) < self.number_clients) + (self.number_clients == 0)

    def _accept_client(self):
        client_socket_id = accept_client_connection(self.PORTNUM)
        last = regint.read_from_socket(client_socket_id)
        return client_socket_id, last
    
    def close_connections(self):
        self._close_connections(self.number_clients)

    def _close_connections(self, number_clients):
        @for_range(number_clients)
        def _(i):
            closeclientconnection(i)

    def receive_from_clients(self, t):
        # Clients secret input.
        self.client_values = t.Array(self.MAX_NUM_CLIENTS)

        @for_range_multithread(self.n_threads, 1, self.number_clients)
        def _(client_id):
            self.client_values[client_id] = self.client_input(t, client_id)
        
        return self.client_values

# Receive from Data Owners authenticated shares of their choices for Data Customer j 
# if cv[i][j] = 1, then Data Owner i agrees to share data with Data Customer j
# if cv[i][j] = 0, then Data Owner i does not want his data to be shared with Data Customer j
# N - number of Data Owners
# M - number of Data Customers
def receive_cv(N, M):
    ccm = ClientConnectionManager(14000, 3, 2)
    cv = ccm.receive_from_clients(sint)
    for id in range(N):
        print_ln("val from client" + str(id) + " is: %s", cv[id].reveal())
    
    ccm.close_connections()

receive_cv(3, 3)