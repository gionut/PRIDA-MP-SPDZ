### Find a way to import mpc files as modules

class ClientConnectionManager:
    def send_to_clients(self, start, end, values, whitelist):
        for i in range(start, end):
            self.send_to_client(self.client_sockets, regint(i), values[i-start])

    def send_to_client(self, sockets, client_id, value):
        """Send value to client"""

        # Setup authenticate result using share of random.
        # client can validate ∑ value * ∑ rnd_from_triple = ∑ auth_result
        sint.reveal_to_clients(sockets.get(client_id), [value])

    def __init__(self, PORTNUM, DO_NUMBER, DC_NUMBER, n_threads):
        self.PORTNUM = PORTNUM
        self.DO_NUMBER = DO_NUMBER
        self.DC_NUMBER = DC_NUMBER
        self.n_threads = n_threads

        # Start listening for client socket connections
        listen_for_clients(self.PORTNUM)
        print_ln('Listening for client connections on base port %s', PORTNUM)

        # Clients socket id (integer).
        self.client_sockets = Array(self.DO_NUMBER + self.DC_NUMBER, regint)
        # Number of clients
        self.number_clients = MemValue(regint(0))
        # Client ids to identity client
        self.client_ids = Array(self.DO_NUMBER + self.DC_NUMBER, sint)
        # Keep track of received inputs
        self.seen = Array(self.DO_NUMBER + self.DC_NUMBER, regint)
        self.seen.assign_all(0)

        # Loop round waiting for each client to connect
        @do_while
        def client_connections():
            client_id = self._accept_client()
            @if_(client_id >= self.DO_NUMBER + self.DC_NUMBER)
            def _():
                print_ln('client id too high')
                crash()
            self.client_sockets[client_id] = client_id
            self.client_ids[client_id] = client_id
            self.seen[client_id] = 1
            
            return (sum(self.seen) < self.DO_NUMBER + self.DC_NUMBER)
        
        self.number_clients.write(self.DO_NUMBER + self.DC_NUMBER)

    def _accept_client(self):
        client_socket_id = accept_client_connection(self.PORTNUM)
        return client_socket_id
    
    def close_connections(self, start, end):
        self._close_connections(start, end)

    def _close_connections(self, start, end):
        @for_range(start, end)
        def _(i):
            closeclientconnection(i)

    def client_input(self, t, size, client_socket_id):
        """
        Send share of size random values, receive input and deduce shares.
        """
        
        return t.receive_from_client(size, client_socket_id)

    def receive_from_clients(self, t, size):
        # Clients secret input.
        self.client_values = t.Matrix(self.DO_NUMBER, size)

        @for_range_multithread(self.n_threads, 1, self.number_clients-self.DC_NUMBER)
        def _(client_id):
            self.client_values[client_id] = self.client_input(t, size, client_id)
        
        return self.client_values

# Receive from Data Owners authenticated shares of their choices for Data Customer j 
# if cv[i][j] = 1, then Data Owner i agrees to share data with Data Customer j
# if cv[i][j] = 0, then Data Owner i does not want his data to be shared with Data Customer j
# N - number of Data Owners
# M - number of Data Customers
def receive_data(ccm, N, M):
    shares = ccm.receive_from_clients(sint, 2*M)
    ccm.close_connections(0, N)
    cv = sint.Matrix(N, M)
    d = sint.Matrix(N, M)
    for id in range(N):
        cv[id] = shares[id][:M]
        d[id] = shares[id][M:]

    return (cv, d)

def preliminary_counting(cv, N, M):
    result = sint.Array(M)
    result.assign_all(0)

    for i in range(N):
        for j in range(M):
            result[j] += cv[i][j]

    return result

def main():
    N = 3  # Data Owners
    M = 1 # Data Customers
    threshold = 2
    
    ccm = ClientConnectionManager(14000, N, M, 2)
    (cv, d) = receive_data(ccm, N, M)

    cv_total = preliminary_counting(cv, N, M).reveal_list()
    whitelist = [cv <= threshold for cv in cv_total]

    res = sint.Array(M)
    res.assign_all(0)
    for j in range(M):
        for i in range(N):
            res[j] += d[i][j]
    
    ccm.send_to_clients(N, N+M, res, whitelist)
    ccm.close_connections(N, N+M)

main()