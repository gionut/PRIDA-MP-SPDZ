### Find a way to import mpc files as modules

from Compiler.types import sint, regint, Array, MemValue
from Compiler.library import print_ln, do_while, for_range
from Compiler.util import if_else

class ClientConnectionManager:

    def __init__(self, PORTNUM, MAX_NUM_CLIENTS, n_threads):
        self.PORTNUM = PORTNUM
        self.MAX_NUM_CLIENTS = MAX_NUM_CLIENTS
        self.n_threads = n_threads

        # Start listening for client socket connections
        listen_for_clients(self.PORTNUM)
        print_ln('Listening for client connections on base port %s', PORTNUM)

        # Clients socket id (integer).
        self.client_sockets = Array(self.MAX_NUM_CLIENTS, regint)
        # Number of clients
        self.number_clients = MemValue(regint(0))
        # Client ids to identity client
        self.client_ids = Array(self.MAX_NUM_CLIENTS, sint)
        # Keep track of received inputs
        self.seen = Array(self.MAX_NUM_CLIENTS, regint)
        self.seen.assign_all(0)

        # Loop round waiting for each client to connect
        @do_while
        def client_connections():
            client_id, last = self._accept_client()
            @if_(client_id >= self.MAX_NUM_CLIENTS)
            def _():
                print_ln('client id too high')
                crash()
            self.client_sockets[client_id] = client_id
            self.client_ids[client_id] = client_id
            self.seen[client_id] = 1
            @if_(last == 1)
            def _():
                self.number_clients.write(client_id + 1)

            return (sum(self.seen) < self.number_clients) + (self.number_clients == 0)

    def _accept_client(self):
        client_socket_id = accept_client_connection(self.PORTNUM)
        last = regint.read_from_socket(client_socket_id)
        return client_socket_id, last
    
    def close_connections(self):
        self._close_connections(self.number_clients)

    def _close_connections(self, number_clients):
        @for_range(number_clients)
        def _(i):
            closeclientconnection(i)

    def receive_from_clients(self, t, size):
        # Clients secret input.
        self.client_values = t.Matrix(self.MAX_NUM_CLIENTS, size)

        @for_range_multithread(self.n_threads, 1, self.number_clients)
        def _(client_id):
            self.client_values[client_id] = self.client_input(t, size, client_id)
        
        return self.client_values

    def client_input(self, t, size, client_socket_id):
        """
        Send share of size random values, receive input and deduce shares.
        """
        
        return t.receive_from_client(size, client_socket_id)


    def send_to_client(self, sockets, client_id, value):
        """Send value to client"""
        # Setup authenticated result using share of random.
        # client can validate ∑ value * ∑ rnd_from_triple = ∑ auth_result
        sint.reveal_to_client(sockets.get(client_id), [value])

# Receive from Data Owners authenticated shares of their choices for Data Customer j 
# if cv[i][j] = 1, then Data Owner i agrees to share data with Data Customer j
# if cv[i][j] = 0, then Data Owner i does not want his data to be shared with Data Customer j
# N - number of Data Owners
# M - number of Data Customers
def receive_data(N, M):
    ccm = ClientConnectionManager(14000, 3, 2)
    shares = ccm.receive_from_clients(sint, 2*M)
    cv = sint.Matrix(N, M)
    d = sint.Matrix(N, M)
    for id in range(N):
        cv[id] = shares[id][:M]
        d[id] = shares[id][M:]
        # print_ln(f"cv for data owner {id} is '%s'", cv[id].reveal())
        # print_ln(f"cv for data owner {id} is '%s'", d[id].reveal())
    
    ccm.close_connections()

    return (cv, d)

def preliminary_counting(cv, N, M):
    result = sint.Array(M)
    result.assign_all(0)

    for i in range(N):
        for j in range(M):
            result[j] += cv[i][j]

    return result

def main():
    N = 3 # Data Owners
    M = 3 # Data Customers
    threshold = 2

    (cv, d) = receive_data(N, M)

    cv_total = preliminary_counting(cv, N, M).reveal_list()
    whitelist = [cv <= threshold for cv in cv_total]

    res = sint.Array(M)
    res.assign_all(0)
    for j in range(M):
        for i in range(N):
            res[j] += d[i][j]
    
    #ccm.send_to_client()

main()